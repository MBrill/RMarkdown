---
title: "Intervallschätzer"
author: "Manfred Brill"
date: "Sommersemester 2021"
output: 

  html_document: 
    fig_caption: yes
    highlight: pygments
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_float: yes  
    
  html_notebook:
    highlight: pygments
    number_sections: yes
    theme: cosmo
    toc: yes
    encoding: utf-8   
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(kableExtra)
suppressPackageStartupMessages(library(dplyr))
library(tidyverse)

library(RColorBrewer)
myPalette <- brewer.pal(5, "YlGn")
# Ausgabe von double-Werte mit  zwei Stellen hinter dem Komma
options(digits=4)
```

# Beispiel Reißfestigkeit
In den Folien wird auch ein Beispiel für die Reißfestigkeit betrachtet. 
Wir verwenden die Normalverteilung und schätzen die Parameter dafür mit 
gegebenen fünf Werten. Aus früheren Untersuchungen kennen wir
den Wert der Standardabweichung, er ist als $\sigma_0=5$ gegeben.

Wir berechnen im ersten Schritt den Faktor $\frac{\sigma_0}{\sqrt{n}}$,
der auch *standard error of the mean* oder kurz *sem* genannt wird.
In den Formeln sehen wir, dass wie die Prognose-Intervall
dadurch berechnen, dass wir diesen Fehler mit den Quantilen multiplizieren.

```{r festigkeit,  message=FALSE, echo=TRUE, results='asis'}
festigkeit <- c(106.0, 102.0, 94.0,107.0, 99.0)
n <- length(festigkeit)
sigma_0 <- 5.0

mu_est <- mean(festigkeit)
```

Dafür erhalten wir die Punktschätzungen `r mu_est` für den Erwartungswert.


```{r sem,  message=FALSE, echo=TRUE, results='asis'}
sem <- sigma_0/sqrt(n)
```

Wir erhalten als Ergebnis für sem den Wert `r sem`.

# Ein Prognose-Intervall zum Niveau 95%

Wir berechnen die Quantile für das gewählte Niveau, dann können wir
das Prognose-Intervall angeben.

```{r prognose95,  message=FALSE, echo=TRUE, results='asis'}
alpha = 0.05

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als
[ `r prognose` ].

# Ein Prognose-Intervall zum Niveau 99%

Wir berechnen die Quantile für das gewählte Niveau, dann können wir
das Prognose-Intervall angeben.

```{r prognose99,  message=FALSE, echo=TRUE, results='asis'}
alpha = 0.01

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als
[ `r prognose` ].


# Ein Prognose-Intervall mit einer größeren Stichprobe

Wir vergleichen die Prognose-Intervalle, falls wir mehr als
die fünf Werte in der Stichprobe haben.

```{r prognose9510,  message=FALSE, echo=TRUE}
festigkeit2 <- c(106, 102, 94, 107, 99, 103, 98, 101, 102, 90)
``` 

```{r prognose9510Comp,  message=FALSE, echo=FALSE}
n <- length(festigkeit2)
sigma_0 <- 5.0

mu_est <- mean(festigkeit2)
sem <- sigma_0/sqrt(n)

alpha = 0.05

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha` für 
die jetzt gegebenen `r n` Stichprobenwerte, zum Niveau `r 1 - alpha`, ist gegeben als
[ `r prognose` ].

# Kleines Intervall durch Senken des Niveaus

Wir hatten bereits festgehalten, dass wir für den gleichen Stichprobenumfang n und ein kleines Niveau (also größere Irrtumswahrscheinlichkeit) ein kleineres Prognose-Intervall erhalten.
Das führen wir jetzt durch.

```{r prognose9010Comp,  message=FALSE, echo=FALSE}
alpha = 0.1

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha` für 
die jetzt gegebenen `r n` Stichprobenwerte, zum Niveau `r 1 - alpha`, ist gegeben als
[ `r prognose` ].

# Berechnung des Stichprobenumfangs

Für gegebene Werte von $\alpha$ und $n$ können wie die Länge
des Prognose-Intervalls angeben. Mit den Berechnungen aus dem letzten 
Beispiel finden wir diese Länge aus den Variablen *sem*
und *ub*:

```{r prognoseL, echo=TRUE}
prognose_length <- 2.0*ub*sem
```


Als Ergebnis für das Prognose-Intervall mit Irrtumswahrscheinlichkeit
$\alpha$ = 0.1 erhalten wir `r prognose_length`.

Diese Berechnung enthält die Länge des Prognose-Intervalls, das Quantil
für die Irrtumswahrscheinlichkeit und den Umfang der Stichprobe.
Geben wir $\alpha$ und die Länge des Prognose-Intervalls vor, dann können wir nach $n$ auflösen und damit für eine gewünschte Länge des Prognose-Intervalls den notwendigen Umfang der Stichprobe vorgeben.
Wir führen eine Berechnung durch, bei der wir ein Prognose-Intervall
der Länge 2 suchen, mit einer Irrtumswahrscheinlichkeit von 5%.
Dabei verwenden wir wie bisher auch den Wert 5.0 für die Standardabweichung.

```{r umfangCom, echo=TRUE}
prognose_length <- 2.0
alpha = 0.05
ub = qnorm(1-alpha/2)

n <- 2.0*sigma_0*ub/prognose_length
n <- ceiling(n**2)
```

Wir runden die Lösung nach oben auf und erhalten für den Umfang der
Stichprobe eine Mindestzahl von `r n` Stichproben.

# Einseitige Konfidenz-Intervalle

In den Anwendungen gibt es häufig Forderungen wie *das Gewicht des Pakets ist mindestens 90g*. Also Ungleichungen, die wir mit 
$\leq$ oder $\geq$ formulieren können. Eine andere Formulierung
ist dann ein Intervall, das $\infty$ oder $-\infty$ enthält.
Dadurch entstehen *einseitige Konfidenz-Intervalle*, die wir
analog zu den bisher betrachteten Intervallen berechnen können.
Wir verwenden Quantile, in den wir statt $1-\alpha/2$
den Wert $1-\alpha$ verwenden.

# Intervall-Schätzungen mit unbekannte Standardabweichung

Wie gehen wir vor, wenn die Standardabweichung der Verteilung
unbekannt ist. Als Punktschätzer für die Varianz einer Verteilung
mit unbekanntem Erwartungswert haben wir die Stichprobenvarianz
eingeführt. Ziehen wir daraus die Wurzel erhalten wir
eine weitere Stichprobenfunktion, die 
*Stichprobenstandardabweichung*.

Wir können jetzt aber nicht mehr die Quantile der Normalverteilung
verwenden, um die Intervallgrenzen zu berechnen. Wir müssen
dafür jetzt die t-Verteilung verwenden. Diese Quantile stehen
in R zur Verfügung, so dass sich nicht viel ändert.

Es gibt ein Markdown-File mit Bildern für die Dichte und die
Verteilungsfunktion der t-Verteilung. Die t-Verteilung
hat einen Parameter n, die Anzahl der Freiheitsgrade.
Ab 2 Freiheitsgraden hat die t-Verteilung den Erwartungswert 0,
ab 3 Freiheitsgraden ist die Varianz gegeben als n/(n-2).

Die Intervallschätzungen für den Erwartungswert berechnen wir analog
zu den Schätzungen im Fall, dass wir die Standardabweichung
der untersuchten Verteilung kennen. Wir berechnen das Stichprobenmittel
und die Stichprobenstandardabweichung. Als Multiplikator
verwenden wir jetzt nicht die Quantile der Standardnormalverteilung,
sondern für n Stichprobenwerte verwenden wir die entsprechenden Quantile der t-Verteilung mit n-1 Freiheitsgraden.

Wir führen diese Berechnungen wieder am Beispiel unserer Reißfestigkeit durch. Wir verwenden die Normalverteilung und schätzen die Parameter dafür mit 
gegebenen fünf Werten. Wir wiederholen die Berechnungen um sicher zu gehen, dass alle Variablen korrekt besetzt sind.

```{r festigkeit2,  message=FALSE, echo=TRUE, results='asis'}
festigkeit <- c(106.0, 102.0, 94.0,107.0, 99.0)
n <- length(festigkeit)
mu_est <- mean(festigkeit)
var_est <- var(festigkeit)
sd_est <- sd(festigkeit)
```

Dafür erhalten wir die Punktschätzungen `r mu_est` für den Erwartungswert.
Hier alle berechneten Werte in einer Tabelle:

| Parameter         | Werte     |
| ------------------ | -------------- |
| Stichprobenmittel  | `r mu_est` |
| Stichprobenvarianz | `r var_est` |
| Stichprobenstandardabweichung | `r sd_est`|
| ------------------ | -------------- |


Jetzt verwenden wir statt der bekannten Standardabweichung
in unserer Berechnung für den *standard error of mean*
den Punktschätzer aus der Stichprobenstandardabweichung:

```{r semt,  message=FALSE, echo=TRUE, results='asis'}
sem <- sd_est/sqrt(n)
```

Wir erhalten als Ergebnis für sem den Wert `r sem`.

Wieder verwenden wir das Niveau 95%, also 5% Irrtumswahrscheinlichkeit
Die berechnungen bleiben fast gleich, wir ersetzen
die Funktion *qnorm* durch *qt$. Dabei achten wir darauf, dass
wir mit dem Parameter *df* die erforderliche Anzahl der Freiheitsgrade
übergeben.

Bevor wir dies ausführen vergleichen wir diese Werte.
Für den Wert 0.975 ist das Quantil der Standardnormalverteilung
durch u(0.975) = `r qnorm(0.975)` gegeben. Verwenden wir
auf Grund von n=5 4 Freiheitsgrade für die t-Verteilung, dann
erhalten wir den korrespondierenden Wert 
$\tau$(0.975) = `r qt(p=0.975, df=4)`.


```{r prognose95t,  message=FALSE, echo=TRUE, results='asis'}
alpha = 0.05

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qt(qu, df = n-1)
lb <- qt(ql, df = n-1)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als
[ `r prognose` ].
Wir können dieses Ergebnis mit einem Intervall vergleichen, das wir erhalten würden, wenn wir die Quantile der t-Verteilung durch die
der Standardnormalverteilung erhalten. Die durch den *studentisierten
Mittelwert* berechneten Prognose-Intervalle sind größer.

Wie schon bei bekannter Standardabweichung können wir jetzt auch 
die Irrtumswahrscheinlichkeit oder den Stichproben-Umfang verändern.
Die Effekte die auftreten sind analog zu denen, die wir bereits
festgehalten haben.

# Intervallschätzungen für die Varianz
Auch für die Varianz einer untersuchten verteilung können
wir Intervallschätzungen erstellen. Dabei benötigen wir
eine weitere Verteilung, die Chi-Quadrat-Verteilung und ihre
Quantile. Diese Verteilung steht in R als *chisq* zur Verfügung,
so dass das Vorgehen analog zu bisher verläuft. Der einzige
Unterschied den man beachten sollte ist, dass diese Verteilung
nicht mehr symmetrisch ist, was man bei der Standardnormalverteilung oder der t-Verteilung verwenden kann. Auch für diese Verteilung
gibt es ein Markdown-Dokument mit grafischen Darstellungen
von Dichten und Verteilungsfunktionen.

Als Stichprobenfunktionen verwenden wir die Stichprobenvarianz
und die Stichprobenstandardabweichung. Auch hier verwenden wir
wieder unser Beispiel der Stichprobe bei der Untersuchung der Reißfestigkeit in einem Unternehmen.

```{r festigkeitvar05,  message=FALSE, echo=TRUE, results='asis'}
festigkeit <- c(106.0, 102.0, 94.0,107.0, 99.0)
n <- length(festigkeit)
var_est <- var(festigkeit)

alpha = 0.05

ql <- 1.0 - alpha/2
qu <- alpha/2.0

lb <- qchisq(ql, df = n-1)
ub <- qchisq(qu, df = n-1)

# Grenzen
a <- (n-1)/lb * var_est
b <- (n-1)/ub * var_est

# Intervall
prognose <-  c(a, b)
```
Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, für die Varianz ist gegeben als
[ `r prognose` ].

Wir berechnen eine weitere Schätzung, dieses Mal mit Irrtumswahrscheinlichkeit 0.1. Hier erwarten wir dann ein
kleineres Intervall, da wir eine größere Unsicherheit zulassen.

```{r festigkeitvar10,  message=FALSE, echo=FALSE, results='asis'}
alpha = 0.1

ql <- 1.0 - alpha/2
qu <- alpha/2.0

lb <- qchisq(ql, df = n-1)
ub <- qchisq(qu, df = n-1)

# Grenzen
a <- (n-1)/lb * var_est
b <- (n-1)/ub * var_est

# Intervall
prognose <-  c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, für die Varianz ist gegeben als
[ `r prognose` ].