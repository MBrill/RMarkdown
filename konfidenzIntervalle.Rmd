---
title: "Konfidenzintervalle"
author: "Manfred Brill"
output: 

  html_document: 
    fig_caption: yes
    highlight: pygments
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_float: yes  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(kableExtra)
suppressPackageStartupMessages(library(dplyr))
library(tidyverse)

library(RColorBrewer)
myPalette <- brewer.pal(5, "YlGn")
# Ausgabe von double-Werte mit  zwei Stellen hinter dem Komma
options(digits=3)
```

# Konfidenzintervalle
Im Skript zu schließender Statistik führen wir Konfidenzintervalle ein
und berechnen diese auch für Beispiele. In Excel gibt es eine Funktion
*KONFIDENZ*, die das Intervall berechnet. Das fehlt in R, so dass in diesem
Markdown die Berechnung als Funktion implementiert wird.

# Implementierung aus rloggers
Wir verwenden das Package *magrittr*, so dass die Pipelines in den Funktionen
einfach zu implementieren sind.

Die Funktionen stammen von der URL <https://www.r-bloggers.com/2021/04/calculating-confidence-interval-in-r/>.


## Konfidenzintervall bei bekannter Varianz
Wenn wir die Varianz kennen verwenden wir die Quantile der Normalverteilung
für die Berechnung des Konfidenzintervalls. Wir implementieren zuerst 
den  zweiseitigen Fall, einseitige Intervalle könnte man gut als Übung
realisieren.


```{r zintervall, echo=TRUE, warnings=TRUE}
CI_z <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`
standard_deviation <- sd(x)
sample_size <- length(x)
Margin_Error <- abs(qnorm((1-ci)/2))* standard_deviation/sqrt(sample_size)
df_out <- data.frame( sample_size=length(x), Mean=mean(x), sd=sd(x),
Margin_Error=Margin_Error,
'CI lower limit'=(mean(x) - Margin_Error),
'CI Upper limit'=(mean(x) + Margin_Error)) %>%
tidyr::pivot_longer(names_to = "Measurements", values_to ="values", 1:6 )
return(df_out)
}
```

## Konfidenzintervall für unbekannte Varianz
Wenn wir die Varianz nicht kennen und sie mit Hilfe des berechneten Mittelwerts
schätzen verwenden wir die Quantile der t-Verteilung für die Berechnung der Intervall.
Ansonsten ist die neue Funktion nicht sehr unterschiedlich von der vorher.

```{r tintervall, echo=TRUE, warnigs=TRUE}
CI_t <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`
Margin_Error <- qt(ci + (1 - ci)/2, df = length(x) - 1) * sd(x)/sqrt(length(x))
df_out <- data.frame( sample_size=length(x), Mean=mean(x), sd=sd(x),
Margin_Error=Margin_Error,
'CI lower limit'=(mean(x) - Margin_Error),
'CI Upper limit'=(mean(x) + Margin_Error)) %>%
tidyr::pivot_longer(names_to = "Measurements", values_to ="values", 1:6 )
return(df_out)
}
```

## Test
In der URL werden Daten für den Test angegeben. Wir kopieren diese Daten in unser
Dokument, dann können wir überprüfen, ob die Implementierung korrekt ist. 

```{r testmitt, echo=TRUE, warnigs=TRUE}
dat <- c(15.4,9.21,4.2,7.5,12.2,18.3,17.3,
14.3,14.02, 20, 12.3, 14.1, 17.3, 15.4,
12.2,11.4, 9.1,18,14.43,17,15.1,13.4,
15.3, 12.2,13.3)

CI_t(dat, ci = 0.95)
## # A tibble: 6 x 2
## Measurements values
## <chr> <dbl>
## 1 sample_size 25
## 2 Mean 13.7
## 3 sd 3.60
## 4 Margin_Error 1.49
## 5 CI.lower.limit 12.2
## 6 CI.Upper.limit 15.2

CI_z(dat, ci = 0.95)
## # A tibble: 6 x 2
## Measurements values
## <chr> <dbl>
## 1 sample_size 25
## 2 Mean 13.7
## 3 sd 3.60
## 4 Margin_Error 1.41
## 5 CI.lower.limit 12.3
## 6 CI.Upper.limit 15.1
```

Die berechneten Werte stimmen mit den Werten in den Kommentaren überein.

# Anpassung der Implementierung
Wir passen jetzt die Implementierung an. Wir
-  nehmen in den Namen der Funktion auf, dass wir twosided rechnen,
- wir verändern die Bezeichner im tibble, das wir zurückgeben.

## Konfidenzintervall bei bekannter Varianz

```{r myzintervall, echo=TRUE, warnings=TRUE}
ConfidenceZ2 <- function (x, sd, ci = 0.95)
{
`%>%` <- magrittr::`%>%`
standard_deviation <- sd
sample_size <- length(x)
Margin_Error <- abs(qnorm((1-ci)/2))* standard_deviation/sqrt(sample_size)

df_out <- data.frame( Niveau=ci, n=length(x), 
                      Mittelwert=mean(x), 
                      Standardabweichung=sd,
                      'Linke Grenze'=(mean(x) - Margin_Error),
                      'Rechte Grenze'=(mean(x) + Margin_Error)) %>%
  tidyr::pivot_longer(names_to = "Bekannte Varianz", values_to ="Werte", 1:6 )

return(df_out)
}

ConfidenceZ2(dat, 3.6)
```

## Konfidenzintervall bei unbekannter Varianz mit der t-Verteilung

```{r mytintervall, echo=TRUE, warnigs=TRUE}
ConfidenceT2 <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`

Margin_Error <- qt(ci + (1 - ci)/2, df = length(x) - 1) * sd(x)/sqrt(length(x))

df_out <- data.frame( Niveau=ci, 
                      n=length(x), 
                      Mittelwert=mean(x), 
                      Standardabweichung=sd(x),
                      'Linke Grenze'=(mean(x) - Margin_Error),
                      'Rechte Grenze'=(mean(x) + Margin_Error)) %>%
  tidyr::pivot_longer(names_to = "Unbekannte Varianz", values_to ="Werte", 1:6 )

return(df_out)
}

ConfidenceT2(dat)
```

# Beispiele aus dem Skript
Wir verwenden jetzt das Beispiel der Reißfestigkeit und berechnen die Werte, die im Skript angegeben wurden mit Hilfe unserer Funktionen. Wir erzeugen die beiden Datenvektoren:

```{r reissfestigkeit, echo=TRUE, warnigs=TRUE}
x5 <- c(106, 102, 94, 107, 99)
x10 <- c(106, 102, 94, 107, 99, 103, 98, 101, 102, 90)
```

## Konfidenzintervall bei bekannter Varianz
Wir berechnen das Intervall bei bekannter Varianz

```{r Zexample5, echo=TRUE, warnigs=TRUE}
sd <- 5.0

ConfidenceZ2(x5, sd)

ConfidenceZ2(x5, sd, ci=0.99)
```

```{r Zexample10, echo=TRUE, warnigs=TRUE}
sd <- 5.0

ConfidenceZ2(x10, sd, ci=0.9)

ConfidenceZ2(x10, sd)
```

## Konfidenzintervall bei unbekannter Varianz
Wir berechnen das Intervall bei bekannter Varianz

```{r texample5, echo=TRUE, warnigs=TRUE}
ConfidenceT2(x5)
```

Wir verwenden die Standardabweichung, die wir gerade berechnet haben und verwenden die Normalverteilung für die Berechnung des Konfidenzintervalls:

```{r texample5a, echo=TRUE, warnigs=TRUE}
ConfidenceT2(x5)

sd <- sd(x5)
ConfidenceZ2(x5, sd)

ConfidenceT2(x10)
```

# Konfidenzintervall für die Standardabweichung
Im Skript geben wir auch ein Konfidenzintervall für die Standardabweichung an.
Dafür benötigen wir die Quantile der Chi-Quadrat Verteilung, was aber
in R kein Problem ist. Wir implementieren analog zu oben eine Funktion dafür.

```{r mysdintervall, echo=TRUE, warnigs=TRUE}
ConfidenceVar2 <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`

nMinus1 <- length(x)-1

Margin_ErrorLeft <- (nMinus1/qchisq(ci + (1 - ci)/2, df = nMinus1) * var(x))
Margin_ErrorRight <- (nMinus1/qchisq((1 - ci)/2, df = nMinus1) * var(x))

df_out <- data.frame( Niveau=ci, 
                      n=length(x), 
                      Mittelwert=mean(x), 
                      Standardabweichung=sd(x),
                      Varianz=var(x),
                      'Linke Grenze'=(Margin_ErrorLeft),
                      'Rechte Grenze'=(Margin_ErrorRight)) %>%
  tidyr::pivot_longer(names_to = "Konfidenzintervall für die Varianz", values_to ="Werte", 1:7 )

return(df_out)
}

ConfidenceVar2(x5)

ConfidenceVar2(x5, 0.99)

ConfidenceVar2(x10)
```

# Konfidenzintervalle für die Binomialverteilung
Im Skript geben wir auch ein Konfidenzintervall an, falls wir eine Binomialverteilung
vorliegen haben an. Dabei nähern wir die Binomialverteilung durch die Normalverteilung
an.

```{r mybinomintervall, echo=TRUE, warnigs=TRUE}
ConfidenceBinom2 <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`

p <- mean(x)
sample_size <- length(x)
Margin_Error <- abs(qnorm((1-ci)/2)) * sqrt(p*(1-p)/sample_size)

df_out <- data.frame( Niveau=ci, 
                      n=length(x), 
                      Erfolgswahrscheinlichkeit=mean(x), 
                      Standardabweichung=sd(x),
                      Varianz=var(x),
                      'Linke Grenze'=(mean(x) - Margin_Error),
                      'Rechte Grenze'=(mean(x) + Margin_Error)) %>%
  tidyr::pivot_longer(names_to = "Konfidenzintervall für eine Binomialverteilung", values_to ="Werte", 1:7 )

return(df_out)
}
```

Im Skript werden zwei Beispiele betrachtet, einmal eine Umfrage, bei der 236 Studierende befragt werden und wir eine Schätzung für den Anteil der weiblichen Studierenden suchen. 
Hier sind im Skript der Mittelwert angegeben und das Konfidenzintervall wird berechnet.
wir erzeugen die entsprechende Anzahl von Werte mit Hilfe von *rep.int*
und versuchen das Ergebnis zu reproduzieren.

```{r Umfrage, echo=TRUE, warnigs=TRUE}
n <- 236

data <-rep.int(0:1, 118)

ConfidenceBinom2(data)
```

# Konfidenzintervall für eine unbekannte Verteilung
Als letzten Punkt betrachten wir im Skript den Fall, dass wir die Verteilung gar nicht kennen, aber die Stichprobe so groß ist, dass die Voraussetzungen des zentralen
Grenzwertsatzes erfüllt sind. Dann können wir die Quantile der Normalverteilung
verwenden und können auf die t-Verteilung verzichten.

```{r unbekannteVerteilung, echo=TRUE, warnigs=TRUE}
ConfidenceGeneral2 <- function (x, ci = 0.95)
{
`%>%` <- magrittr::`%>%`

Margin_Error <- qnorm(ci + (1 - ci)/2) * sd(x)/sqrt(length(x))

df_out <- data.frame( Niveau=ci, 
                      n=length(x), 
                      Mittelwert=mean(x), 
                      Standardabweichung=sd(x),
                      'Linke Grenze'=(mean(x) - Margin_Error),
                      'Rechte Grenze'=(mean(x) + Margin_Error)) %>%
  tidyr::pivot_longer(names_to = "Unbekannte Verteilung", values_to ="Werte", 1:6 )

return(df_out)
}
```

Als Beispiel hatten wir Werte für eine Stichprobe der Reißfestigkeit angegeben,
bei der der Mittelwert und die Varianz bekannt sind. Das simulieren wir
mit Hilfe von Zufallszahlen. Dann weichen zwar die Werte leicht ab,
aber wir sollten durchaus ähnliche Ergebnisse haben.

```{r stichprobe, echo=TRUE, warnigs=TRUE}
n <- 100

data <- rnorm(n, mean=732.0, sd = 2.68)
data

ConfidenceGeneral2(data)
```

Diese Werte können wir auch für eine Übungsaufgabe einsetzen!
