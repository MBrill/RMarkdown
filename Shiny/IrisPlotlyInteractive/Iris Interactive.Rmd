---
title: "Interactive document: Iris Interactive"
author: "Julian Bernhart"
date: '2022-07-07'
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

{r, code = readLines('tabData.R')}
{r, file = 'external.R'}


```{r, include=FALSE, echo=FALSE}
library(shiny)
library(DT)
```

This document describes based on a demo the basic structure of the Iris Interactive project.

## Basic Structur

The Code for this project is modularized. 
The UI function consists of a navbarPage with the individual tabPanels and the themeSelector for Shiny Apps. In the main Shiny App the themeSelector is outsourced to a separate tab called Settings.

```{r}
# UI-object for the Shiny App.
ui <- shinyUI(
  tagList(
    # Creates a draggable fixed Panel handling the theme selection.
    shinythemes::themeSelector(),
    navbarPage(
      title = "NavbarPage",
      tabPanel("Tab 1"),
      tabPanel("Tab 2"),
      tabPanel("Tab 3")
      # ...
    )
  )
)
```

The server function consists of the server modules corresponding to the tabs of the UI.

```{r}
# Server object for the Shiny App.
server <- shinyServer(function(input, output) {
  # After the function for the necessary server modules are implemented, this is the place to put them.
  # serverTab1()
  # serverTab2()
  # serverTab3()
  # ...
})
```

Running the current App leads to the following UI.  

```{r}
shinyApp(ui, server)
```


## Creating the Tabs

With this setup the tabs can be treated like separate Shiny Apps. The entire code for a tab is in one corresponding file. With the help of dedicated namespaces it is possible to separate the different tabs from each other. 
An example is described below.

First a ID for the tab is defined:

```{r}
IDTAB1 <- "tab1"
```

With the ID the new UI and sever for Tab1 can be created:
ID is handed to UI and server function.
These function will define the content of the tab. 

```{r}
uiTab1 <- function(id = IDTAB1){
  # The namespace is used for every element in the UI. With the help of the ns variable it is possible to address UI elements with "n(<UIID>)" instead of NS(id, <UIID>).
  ns <- NS(id)
  # Define a custom tagList of UI elements. 
  tagList(
    # ...
  )
}

serverTab1 <- function(id = IDTAB1){
  # The namespace for the server is defined by the id. It is not necessary to address UI elements like in the uiTab1 function. All elements are addressable by input$<elementID>.
  moduleServer(id, function(input, output, session) {
    # ...
  })
}
```


The next step is to fill the UI and server functions. In this case the tab consists of a datatable which contains the iris data set.

```{r}
uiTab1 <- function(id = IDTAB1){
  ns <- NS(id)
  tagList(
    fluidPage(
      fluidRow(
        column(12, DTOutput(ns("table")))
      )
    )
  )
}

serverTab1 <- function(id = IDTAB1){
  moduleServer(id, function(input, output, session) {
    output$table <- renderDT(iris)
  })
}
```

The final step is to adjust the UI and server functions accordingly.

```{r}
ui <- shinyUI(
  tagList(
    shinythemes::themeSelector(),
    navbarPage(
      title = "NavbarPage",
      tabPanel("Tab 1", uiTab1()),
      tabPanel("Tab 2"),
      tabPanel("Tab 3")
      # ...
    )
  )
)
server <- shinyServer(function(input, output) {
  serverTab1()
  # serverTab2()
  # serverTab3()
  # ...
})

```
```{r, echo=FALSE}
shinyApp(ui, server)
```
