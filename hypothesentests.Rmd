---
title: "Hypothesentests mit einer Stichprobe"
author: "Manfred Brill"
date: "Sommersemester 2021"
output: 

  html_document: 
    fig_caption: yes
    highlight: pygments
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_float: yes  
    
  html_notebook:
    highlight: pygments
    number_sections: yes
    theme: cosmo
    toc: yes
    encoding: utf-8   
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(kableExtra)
suppressPackageStartupMessages(library(dplyr))
library(tidyverse)

library(RColorBrewer)
myPalette <- brewer.pal(5, "YlGn")
# Ausgabe von double-Werte mit  zwei Stellen hinter dem Komma
options(digits=4)
```

# Hypothesentests mit einer Stichprobe und bekannter Standardabweichung

## Zweiseitige Hypothesentests

```{r stichprobe, include=FALSE, echo=FALSE}
mu_h0 <- 500.0
n <- 25
mu_est <- 499.28

sigma2 <- 2.25
sigma_0 <- sqrt(sigma2)
```

In den Folien wird ein Beispiel mit der Füllmenge von Flaschen in 
einer Brauerei betrachtet. Als Nullhypothese gehen wir davon aus,
dass die mittlere Füllhöhe der Flaschen durch `r mu_h0` cm$^3$ gegeben ist.
Ab sofort lassen wir die Einheit der Füllhöhe im Text weg.

Wir überprüfen diese Nullhypothese H0 gegen die Gegenhypothese
H1, dass die mittlere Füllhöhe nicht durch diesen Betrag gegeben ist.
Ein solcher Hypothesentest nennen wir **zweiseitiger Hypothesentest**.

Wir gehen bei unserem Test davon aus, dass wir in einer
Stichprobe mit `r n` Flaschen durch das arithmetische Mittel 
`r mu_est` als Punktschätzer erhalten haben.
Aus Unterlagen der Qualitätssicherung
wissen wir, dass die Füllhöhe normalverteilt ist, mit einer Varianz
von `r sigma2`, also einer Standardabweichung von `r sigma_0`.

```{r prognose99,  message=FALSE, echo=TRUE, results='asis'}
sem <- sigma_0/sqrt(n)
alpha <- 0.01

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als [`r prognose`].

Mit 99 Prozent Wahrscheinlichkeit liegt der von uns angenommene Wert von 
`r mu_h0` aus der Nullhypothese in diesem Prognose-Intervall. Dann lehnen wir die Nullhypothese **nicht** ab.

Wir verändern die Irrtumswahrscheinlichkeit auf 0.05 und berechnen dafür das Prognose-Intervall:

```{r prognose95,  message=FALSE, echo=TRUE, results='asis'}
alpha <- 0.05

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qnorm(qu)
lb <- qnorm(ql)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
```

Das Prognose-Intervall mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als [`r prognose`]. Der Wert von 500 aus der Nullhypothese liegt nicht in diesem Intervall. Dann ist der Mittelwert, den wir für das Prognose-Intervall verwenden haben zu unwahrscheinlich - wir verwerfen die Nullhypothese und nehmen die Gegenhypothese, dass die mittlere Füllmenge **nicht** durch 500 gegeben ist, an.

Allgemein bezeichnen wir das in den Beispielen berechnete Prognoseintervall
den **Annahmebereich**. Liegt der Wert aus der Nullhypothse in diesem Intervall,
dann verwerfen wir die Nullhypothese nicht. Das Komplement des Prognoseintervalls
bezeichnen wir aus offensichtlichen Gründen als **Verwerfungsbereich**.

## Einseitige Hypothesentests

Das Eichamt vermutet vermutlich eher, dass die Füllhöhe kleiner als der 
Wert `r mu_h0`ist. Oder das Unternehmens selbst vermutet eventuell,
dass die Füllhöhe zu hoch ist. Solche Thesen können wir mit Hilfe
von **einseitigen Hypothesentests** überprüfen. Hier verwenden wir als
Gegenhypothese keine Ungleichung, sondern eine Ungleichung, entweder 
mit > od er <.

Bei der Berechnung von **Annahme-** und **Verwerfungsbereich**
müssen wir die restlichen Flächen nicht links und rechts anordnen
sondern wir arbeiten mit dem Wert 1 - alpha. 
Für die Nullhypothese H0 verwenden wir als Beispiel
\[
H_0: \mu \geq 500.
\]
Dann ist die Gegenhypothese durch
\[
H_1: \mu < 500
\]
gegeben.

Das Vorgehen ist analog wie beim zweiseitigen Test,
wir berechnen als Annahmebereich ein Intervall, das 
im negativen Unendlich auf dem Zahlenstrahl beginnt und
als rechte Grenze durch das Quantil zur Warscheinlichkeit 1-alpha
gegeben ist. Als Irrtumswahrscheinlichkeit verwenden
wir 5%.

```{r onesided,  message=FALSE, echo=TRUE, results='asis'}
alpha <- 0.05

qu <- 1.0 - alpha

ub <- qnorm(qu)

# Grenze
b <- ub * sem

# Intervall
prognose <- mu_est - b
```

Wir erhalten als rechte Grenze des Annahmebereichs den Wert
`r prognose`. Als Punktschätzer verwenden wir immer noch das arithmetische
Mittel der Stichprobe, der durch `r mu_est` gegeben war.
Mit dem Niveau `r 1 - alpha` verwerfen wir die Nullhypothese und
nehmend die Gegenhypothese an, dass die Füllhöhe mindestens 500 beträgt.

Bemerkung: wenn wir für die Irrtumswahrscheinlichkeit 1% verwenden
wird auch für dieses Niveau die Nullhypothese verworfen!

## Gauß-Test

Bevor wir zu dem Fall gehen, dass wir die Standardabweichung nicht kennen
formulieren wir den Ablauf des beschriebenen Hypothesentests
allgemein. Wir werden bemerken, dass dieser Ablauf so gut wie immer
eingehalten wird.

1. Wir formulieren die Nullhypothese H0 und die Gegenhypothese H1.
1. Wir legen ein Signifikanzniveau 1 - alpha bzw. die Irrtumswahrscheinlichkeit alpha fest. Damit können wir den Annahme- bzw. den Verwerfungsbereich
angeben.
1. Wir berechnen den Wert der **Statistik**, hier den Wert z
für den Punktschätzer des Erwartungswerts.
1. Wir verwerfen H0, falls der Wert der Statistik nicht im Annahmebereich liegt. Liegt der Wert von z im Annahmebereich verwerfen wir die Nullhypothese nicht.

## p-Werte
Neben den beiden Bereichen, die wir für die Annahme oder für das Verwerfen
von Hypothesen aus den Prognose-Intervallen bilden wird in der Praxis
sehr häufig mit dem sogenannten **p-Wert**, im Englischen **p-value**, gearbeitet. Manchmal finden wir auch die Bezeichnung
**observed significance level**.
Dieser Wert ist die Antwort auf die Frage,
wie wahrscheinlich der Wert der Statistik im Schritt 3 ist, wenn
die Nullhypothese gilt. 

Für einen  zweiseitigen Hypothesentest können wir dieses p
berechnen. Der Wert ist gegeben als die Wahrscheinlichkeit,
dass wir den berechnen Wert der Statistik oder noch
unwahrscheinlichere finden. Diese Berechnung können
wir mit der Dichte, hier der Normalverteilung durchführen.
Ist der berechnete p-Wert kleiner als die Irrtumswahrscheinlichkeit
verwerfen wir die Nullhypothese.

```{r pvalue,  message=FALSE, echo=TRUE, results='asis'}
p <- 2.0 * pnorm(mu_est, mean = mu_h0, sd = sem)
```

Wir erhalten für den zweiseitigen Test den Wert `r p` für den p-Wert.
Da er größer ist als 1% verwerfen wir für diese Irrtumswahrscheinlichkeit
die Nullhypothese nicht (was wir ja bereits mit Hilfe des Annahmebereichs
durchgeführt hatten). Für die Irrtumswahrscheinlichkeit 5%
verwerfen wir die Nullhypothese.

Auch für den einseitigen Hypothesentest können wir den p-Wert
berechnen, hier verschwindet allerdings der Faktor 2.

```{r pvalueos,  message=FALSE, echo=TRUE, results='asis'}
p <- pnorm(mu_est, mean = mu_h0, sd = sem)
```

Hier erhalten wir für p den Wert `r p`.

# Hypothesentest mit unbekannter Standardabweichung

In der Praxis werden wir die Standardabweichung für die Grundgesamtheit
häufig nicht kennen. In diesem Fall führen wir einen sogenannten t-Test
durch. Der Ablauf ist genauso wie oben, außer dass wir jetzt zwei
Punktschätzer, für den Erwartungswert und die Varianz, verwenden
und eine Zufallsvariable, eine **Statistik**, einsetzen,
die nicht normal-, sondern t-verteilt ist.

Da uns keine konkreten Werte für die Füllhöhen in der Brauerei
vorliegen verwenden wir stattdessen Stichprobenwerte 
über die Reißfestigkeit, die wir in den Datensätzen
in OLAT finden, die wir bereits als Beispiel für die
Berechnung von Punkt- und Intervallschätzern eingesetzt haben.
Wir führen einen zweiseitigen Hypothesentest aus, dabei 
verwenden wir Nullhypothese, dass der Erwartungswert
der normalverteilten Grundgesamtheit durch 100 gegeben ist.
Als Irrtumswahrscheinlichkeit verwenden wir 5%.

Wir berechnen den Annahmebereich mit Hilfe der Quantile der t-Verteilung.
Sonst entsteht kein großer Unterschied.

```{r ttestreiss,  message=FALSE, echo=TRUE, warnings=FALSE}
festigkeit <- c(106, 102, 94, 107, 99, 103, 98, 101, 102, 90)

mu_h0 <- 100.0
mu_est <- mean(festigkeit)
var_est <- var(festigkeit)
sd_est <- sd(festigkeit)

sem <- sd_est/sqrt(n)

alpha = 0.05

qu <- 1.0 - alpha/2
ql <- alpha/2.0

ub <- qt(qu, df = n-1)
lb <- qt(ql, df = n-1)

# Grenzen
b <- ub * sem
a <- -b

# Intervall
prognose <- mu_est + c(a, b)
``` 

Der Annahmebereich mit Irrtumswahrscheinlichkeit `r alpha`, zum Niveau `r 1 - alpha`, ist gegeben als [`r prognose`]. Der Wert von `r mu_h0` aus der Nullhypothese liegt in diesem Bereich. Wir verwerfen die Nullhypothese nicht.

Auch für diesen Fall können wir p-Werte berechnen, wir verwenden hier
die Funktion *tnorm* für die t-Verteilung. Und auch einseitige Hypothesentests
verlaufen analog wie bisher.

# Hypothesentests in R

## Der Gauß-Test mit der Funktion *z.test*

Natürlich gibt es die Tests die wir vorgestellt haben (und noch viele mehr) als Funktionen in R. Den Hypothesentest mit bekannter Standardabweichung findet man nicht im Default-Paket *stats*, da in der Praxis meist ein t-Test durchgeführt wird. Im Package *TeachingDemos* gibt es aber die Funktion *z.test*, mit der 
man auch diesen Test durchführen kann. In der Doku dieser Funktion findet man schon den Hinweis, dass das nur für *akademische* Zwecke implementiert wurde und man in der Praxis den t-Test mit Hilfe der Funktion *t.test* verwenden soll.
Beide Funktionen erhalten als Argument die komplette Stichprobe. Wir können die Nullhypothese und die Irrtumswahrscheinlichkeit übergeben, als Default wird
von einer Irrtumswahrscheinlichkeit von 5% verwendet.

Da wir eine Stichprobe benötigen verwenden wir die 10 Werte für die Untersuchung der Reißfestigkeit, die wir bereits bei den Intervallschätzern verwendet haben.
Statt alle Variablen zu berechnen übergeben wir die Stichprobe
und verwenden anschließend die Ergebnisse dieser Funktion.

```{r reissgauss,  message=FALSE, echo=TRUE, warnings=FALSE}
library(TeachingDemos)

sigma_0 <- 5.0

res <- z.test(festigkeit, mu=100, sigma_0, 
              conf.level=0.95)

res
``` 

```{r reissgaussvar,  message=FALSE, echo=TRUE, warnings=FALSE}
pv <- res$p.value
statistic <- res$estimate
ci <- res$conf.int
``` 

Wir übergeben den Wert für die Nullhypothese, die bekannte Standardabweichung
und das Konfidenzniveau. In der Struktur, die wir als Ergebnis erhalten
finden wir alle Angaben, die wir benötigen um den Test zu entscheiden.
Wir finden den Punktschätzer für den Erwartungswert und den Annahmebereich,
genauso wie den berechneten p-Wert. Mit Hilfe von beiden Angaben entscheiden wir, dass wir die Nullhypothese nicht verwerfen.
Als p-Wert erhalten wir `r pv`.
Der berechnete Wert der Statistik ist durch `r statistic` gegeben,
der Annahmebereich durch `r ci`.


```{r reissgauss99,  message=FALSE, echo=TRUE, warnings=FALSE}
res <- z.test(festigkeit, mu=100, sigma_0, 
              conf.level=0.99)
pv <- res$p.value
statistic <- res$estimate
ci <- res$conf.int
``` 

wir wiederholen den Test, allerdings verwenden wir dieses Mal
das Niveau 99%. 
Als p-Wert erhalten wir wieder `r pv`.
Der berechnete Wert der Statistik ist immer noch durch `r statistic` gegeben,
der Annahmebereich durch [`r ci`]. Wir verwerfen auch mit diesem Niveau
die Nullhypothese nicht.

Mit der Funktion können wir auch einseitige Hypothesentests durchführen.
Das müssen wir beim Aufruf der Funktion nur übergeben.


```{r reissgaussos,  message=FALSE, echo=TRUE, warnings=FALSE}
res <- z.test(festigkeit, mu=100, sigma_0, 
              alternative="less",
              conf.level=0.95)

res
``` 

Mit den Ausgaben der Funktion erkennen wir, dass auch hier die Nullhypthese
nicht verworfen wird.

## Der t-Test mit der Funktion *t.test*

Es ist nicht überraschend, dass der t-Test im Package *stat* in R
verfügbar ist. Die Funktion funktioniert analog zu *z.test*,
so dass wir sofort den t-Test für unsere Reißfestigkeit durchführen können.


```{r reissstudent,  message=FALSE, echo=TRUE, warnings=FALSE}
res <- t.test(festigkeit, mu=100, 
              conf.level=0.95)

res

pv <- res$p.value
statistic <- res$estimate
ci <- res$conf.int
``` 

Als p-Wert erhalten wir  `r pv`.
Der berechnete Wert der Statistik ist immer noch durch `r statistic` gegeben,
der Annahmebereich durch [`r ci`]. Wir verwerfen auch mit diesem Niveau
die Nullhypothese nicht.

Wiederum können wir auch einen einseitigen Test durchführen:

```{r reissstudentos,  message=FALSE, echo=TRUE, warnings=FALSE}
res <- t.test(festigkeit, mu=100,
              alternative="less",
              conf.level=0.95)

res
``` 

Wir verwerfen die Nullhypothese nicht.